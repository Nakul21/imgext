// Add these functions at the appropriate place in your code

function getMaxTextureSize() {
    const ctx = document.createElement('canvas').getContext('webgl');
    if (!ctx) return 4096; // Default to a reasonable size if WebGL is not supported
    return ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
}

async function preprocessImageForDetection(imageElement) {
    const maxTextureSize = getMaxTextureSize();
    const scale = Math.min(1, maxTextureSize / Math.max(imageElement.width, imageElement.height));
    
    const newWidth = Math.round(imageElement.width * scale);
    const newHeight = Math.round(imageElement.height * scale);

    const canvas = document.createElement('canvas');
    canvas.width = newWidth;
    canvas.height = newHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(imageElement, 0, 0, newWidth, newHeight);

    let tensor = tf.tidy(() => {
        return tf.browser.fromPixels(canvas).toFloat();
    });

    let mean = tf.scalar(255 * DET_MEAN);
    let std = tf.scalar(255 * DET_STD);

    return tensor.sub(mean).div(std).expandDims();
}

async function detectAndRecognizeText(imageElement) {
    if (isMobile()) {
        await tf.setBackend('webgl');
        await tf.ready();
        console.log('Using WebGL backend for mobile');
    }

    const maxTextureSize = getMaxTextureSize();
    console.log('Max texture size:', maxTextureSize);

    // Preprocess the image, ensuring it fits within texture size limits
    const tensor = await preprocessImageForDetection(imageElement);
    
    // Run detection model
    const prediction = await detectionModel.execute({'x': tensor});
    const squeezedPrediction = tf.squeeze(prediction, 0);

    // Convert prediction to heatmap
    const heatmapCanvas = document.createElement('canvas');
    heatmapCanvas.width = tensor.shape[2];
    heatmapCanvas.height = tensor.shape[1];
    await tf.browser.toPixels(squeezedPrediction, heatmapCanvas);

    // Extract bounding boxes
    const boundingBoxes = extractBoundingBoxesFromHeatmap(heatmapCanvas, [tensor.shape[2], tensor.shape[1]]);

    // Scale bounding boxes back to original image size
    const scaleX = imageElement.width / tensor.shape[2];
    const scaleY = imageElement.height / tensor.shape[1];
    boundingBoxes.forEach(box => {
        box.coordinates = box.coordinates.map(coord => [
            coord[0] * scaleX,
            coord[1] * scaleY
        ]);
    });

    // Clean up tensors
    tensor.dispose();
    prediction.dispose();
    squeezedPrediction.dispose();

    // Process each bounding box for text recognition
    // ... (rest of the function remains similar)

    return extractedData;
}

// Modify the init function to include WebGL optimizations
async function init() {
    showLoading('Initializing...');
    
    await tf.ready();
    
    if (isMobile()) {
        console.log('Mobile device detected. Using WebGL backend.');
        await tf.setBackend('webgl');
        
        // Adjust WebGL settings for mobile
        const gl = tf.backend().getGPGPUContext().gl;
        gl.getExtension('OES_texture_float');
        gl.getExtension('WEBGL_color_buffer_float');
        
        // Optimize WebGL settings
        tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
        tf.env().set('WEBGL_RENDER_FLOAT32_CAPABLE', true);
        tf.env().set('WEBGL_FLUSH_THRESHOLD', 1); // Flush more frequently

        console.log('Max texture size:', getMaxTextureSize());
    } else if (await isWebGPUSupported()) {
        // ... (WebGPU setup remains the same)
    } else {
        // ... (Fallback remains the same)
    }
    
    // Load models sequentially
    showLoading('Loading detection model...');
    detectionModel = await tf.loadGraphModel('models/db_mobilenet_v2/model.json');
    
    showLoading('Loading recognition model...');
    recognitionModel = await tf.loadGraphModel('models/crnn_mobilenet_v2/model.json');
    
    console.log('Models loaded successfully');
    
    await setupCamera();
    
    captureButton.disabled = false;
    captureButton.textContent = 'Capture';
    
    hideLoading();
}
