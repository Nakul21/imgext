async function setupCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
        } 
    });
    video.srcObject = stream;
    return new Promise((resolve) => {
        video.onloadedmetadata = () => {
            resolve(video);
        };
    });
}

function preprocessImageForDetection(imageElement) {
    const maxSize = 2048; // Set a maximum size that works for most mobile devices
    const originalWidth = imageElement.width;
    const originalHeight = imageElement.height;
    let newWidth, newHeight;

    if (originalWidth > originalHeight) {
        newWidth = Math.min(originalWidth, maxSize);
        newHeight = (originalHeight / originalWidth) * newWidth;
    } else {
        newHeight = Math.min(originalHeight, maxSize);
        newWidth = (originalWidth / originalHeight) * newHeight;
    }

    const canvas = document.createElement('canvas');
    canvas.width = newWidth;
    canvas.height = newHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(imageElement, 0, 0, newWidth, newHeight);

    const targetSize = [512, 512];
    let tensor = tf.browser
        .fromPixels(canvas)
        .resizeNearestNeighbor(targetSize)
        .toFloat();
    let mean = tf.scalar(255 * DET_MEAN);
    let std = tf.scalar(255 * DET_STD);
    return tensor.sub(mean).div(std).expandDims();
}

async function handleCapture() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const maxSize = 2048;
    let scaleFactor = 1;
    if (canvas.width > maxSize || canvas.height > maxSize) {
        scaleFactor = maxSize / Math.max(canvas.width, canvas.height);
    }
    
    const scaledCanvas = document.createElement('canvas');
    scaledCanvas.width = canvas.width * scaleFactor;
    scaledCanvas.height = canvas.height * scaleFactor;
    scaledCanvas.getContext('2d').drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
    
    imageDataUrl = scaledCanvas.toDataURL('image/jpeg', isMobile() ? 0.7 : 0.9);
    resultElement.textContent = 'Processing image...';
    
    const img = new Image();
    img.src = imageDataUrl;
    img.onload = async () => {
        try {
            loadingIndicator.style.display = 'block';
            const { fullText, extractedWords } = await detectAndRecognizeText(img);
            extractedText = fullText;
            resultElement.textContent = `Extracted Text: ${extractedText}`;
            
            window.extractedWords = extractedWords;
            
            previewCanvas.style.display = 'block';
            confirmButton.style.display = 'inline-block';
            retryButton.style.display = 'inline-block';
            captureButton.style.display = 'none';
        } catch (error) {
            console.error('Error during text extraction:', error);
            resultElement.textContent = 'Error occurred during text extraction';
        } finally {
            loadingIndicator.style.display = 'none';
        }
    };
}
